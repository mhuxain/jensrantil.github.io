<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="http://jensrantil.github.io/theme/css/style.css">
	<!--<link rel="stylesheet/less" type="text/css" href="/theme/css/style.less">-->
	<!--<script src="/theme/js/less.js" type="text/javascript"></script>-->
	<link rel="stylesheet" type="text/css" href="http://jensrantil.github.io/theme/css/pygments.css">
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>

	<link href="http://jensrantil.github.io/" type="application/atom+xml" rel="alternate" title="Jens Rantil's Hideout ATOM Feed" />
	
	
			<title>Jens Rantil's Hideout</title>
		<meta charset="utf-8" />
	</head>
<body>
	<section id="sidebar">
		<figure id="user_logo">
            <a href="http://jensrantil.github.io"><div class="logo">&nbsp;</div></a>
		</figure>

		<div class="user_meta">
            <h1 id="user"><a href="http://jensrantil.github.io" class="">Jens Rantil</a></h1>
			<h2></h2>
						<p class="bio">Swedish/English, fullstack software engineer (<a href="http://www.tinkapp.com" target="_blank">@Tink</a>), <a href="http://www.lth.se/english/education/programmes/master_engineering/engineering_mathematics/">MSc in Engineering Mathematics</a>, traveller, nerd, juggler, guitarist, african drum player. Inspired Swede.</p>
						<ul>
																			<li><a href="http://jensrantil.github.io/pages/about-jens.html">About Jens</a></li>
																		<li><a href="http://www.twitter.com/JensRantil">Twitter</a></li>
									<li><a href="http://www.github.com/JensRantil">Github</a></li>
									<li><a href="http://www.linkedin.com/in/jensrantil">LinkedIn</a></li>
							</ul>
		</div>
		<footer>
			<address>
				Powered by <a href="http://pelican.notmyidea.org/">Pelican</a>,
		                theme by <a href="https://github.com/wting/pelican-svbtle">wting</a>.
			</address>
		</footer>
	</section>

	<section id="posts">
			<header>
		<h1>Jens Rantil's blog</h1>
		<h3>Posted Thu 23 May 2013</h3>
	</header>
	<article>
		<h1 id="title">
			<a href="http://jensrantil.github.io/refreshable-angularjs-service.html" rel="bookmark"
				title="Permalink to Refreshable AngularjS service">Refreshable AngularjS service</a>
		</h1>
		<p>Lately I've been working a lot in <a class="reference external" href="http://angularjs.org">AngularJS</a>. This is my second project
with the framework, and the more time I spend in it, the more I like it.</p>
<p>But as with most things, AngularJS has some rough corners. Its
<a class="reference external" href="http://docs.angularjs.org/">documentation</a> still has a long way to go, although it has improved since
last time I used it over a year ago. Common use cases and &quot;Angular-y&quot;
was of doing things is another thing that I also feel is lacking out
there. I guess it could be considered documentation depending on how you
look at it.</p>
<p>My intention with this blog post is to go through one such use case,
namely dealing with complex dependencies. The clientside application
that I've been working with lately has a bunch of quite complicated
dependencies and these JSFiddles turned out to be the perfect way for me
to flesh out how to deal with the dependencies in an structured fashion.
Specifically, this post will talk about:</p>
<ul class="simple">
<li>How to share state between controllers.</li>
<li>How update/refresh state between controllers.</li>
</ul>
<p>The level of this tutorial is <em>intermediate</em>. I expect you to know basic
AngularJS; state injection, controllers, about <tt class="docutils literal">$timeout</tt> and
services.</p>
<div class="section" id="a-slow-service">
<h2>A slow service</h2>
<p>Let's say you have some data you would like to present to your user
and you prepare some data in your controller. In our case, a list:</p>
<iframe width="100%" height="150"
src="http://jsfiddle.net/Ztyx/U9A32/1/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>This is very basic AngularJS and I expect you to have no problems
understanding the mapping done here.</p>
<p>But in the real world, we rarely hardcode things. We are usually
interested in dynamic data. There are two (major) alternatives to get
dynamic data into an AngularJS browser application - either generating
the data into your JS code, or you make an API call to your backend
after your AngularJS application has loaded. The latter is better if
your data takes some time to generate. If you have multiple
dependencies, fetching them asynchronously using multiple HTTP calls
usually also tend to decrease page loading times.</p>
<p>Now, let's create a <a class="reference external" href="http://docs.angularjs.org/guide/dev_guide.services">service</a> that simulates a slower API call. It uses a
<a class="reference external" href="http://docs.angularjs.org/api/ng.$q">promise</a> to return an handler that deals with handling asynchronous
result. Here's the code:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/2/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>Notice that it takes a couple of seconds before the result is presented
on the screen when you click &quot;Result&quot;.</p>
<p>Also, it's worth making a mental note that we are storing <em>a promise</em> to
the scope. This is not the same as the actual list. AngularJS
automatically resolves this as the actual returned list and presents it
in the generated HTML. One issue with saving a promises directly to the
scope is that you don't handle how to deal with errors if the promise
could not be resolved. Errors <em>do</em> happen, and in most cases you are
better off explicitly dealing with then. Maybe you can simply ignore it?
Present an error message? Revert to the previous message? This why I
nowadays usually resolve all my promises like this:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/3/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>Obviously, we are not generating any errors here, but you never know!
;)</p>
</div>
<div class="section" id="refreshable-data-between-controllers">
<h2>Refreshable data between controllers</h2>
<p>Let's say we would like share state between controllers. This can be
done by nesting controllers. Here's a basic example:</p>
<iframe width="100%" height="200"
src="http://jsfiddle.net/Ztyx/U9A32/4/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>Now, let's say that we would like this state to to refresh ones in a
while. Let's simulate an element added:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/5/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>If you click &quot;Result&quot;, you'll notice that the two child controllers are
not being updated after 3 seconds. That's because their <tt class="docutils literal">$scope</tt>
members only are set when the child controllers are being created. What
we want is to <a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$watch">watch</a> changes made to the list:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/6/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>If you try the code above, you'll notice that it still doesn't work. The
reason is subtle; <tt class="docutils literal"><span class="pre">$scope.$watch</span></tt> compares object by reference by
default. This means that it will check to see if <tt class="docutils literal">$scope.mylist</tt> is a
<em>different</em> array than previously. It is not -- it's simply a modified
version of that same array. What we want is to compare for <em>object
equality</em>. We do that by setting the third parameter to <tt class="docutils literal">true</tt> when
calling <tt class="docutils literal"><span class="pre">$scope.$watch</span></tt>:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/8/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>Finally, it works! But, as in the previous example, we want to avoid
sharing data between controllers through a parent controller. Instead,
we want to use a service:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/10/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>All good in the hood so far. Now, let's say we would like to support
refreshing data from our slow API endpoint. Maybe the user has a little
refresh button, or you'd like the controller to issue a refresh. This is
where things get a little messy.</p>
<p>My first take on this:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/11/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>For simplicity, I've only included a single controller.</p>
<p>Notice that my service now returns an object with the function
<cite>refresh()</cite> bound to it. The <cite>refresh()</cite> member function returns a
new promise every time it's called.</p>
<p>Looking at the result we notice that the result is presented correctly.
However, what's interesting is that <tt class="docutils literal">$scope.watchCallbackCalls</tt>
eventually gets the value <tt class="docutils literal">4</tt>. This is because our promise returned
from <tt class="docutils literal">refresh()</tt> actually is modified twice; first when it's returned
by <tt class="docutils literal">refresh()</tt> and secondly when the promise is resolved. Since we
call <tt class="docutils literal">refresh()</tt> twice, our watcher gets called four times. The
expected number of watch callback calls are obviously 2 calls.</p>
<p>How do we overcome this? Instead of using watchers on promises, we
<a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$on">can</a> <a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$emit">use</a> <a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$broadcast">events</a> when our promises are resolved:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/12/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>Each event is triggered with newly fetched list as event argument.</p>
<p>Since the service can't access the controller that uses it, we trigger
events from <tt class="docutils literal">$rootScope</tt>. For bigger applications you might want to
use the calling controller as a parameter to <tt class="docutils literal">refresh()</tt> to avoid
bloating the <tt class="docutils literal">$rootScope</tt> with too many events (and possibly get
conflicting event names).</p>
<p>Another nice property of using events is that also other services could
have <tt class="docutils literal">MySimulatedSlowHTTPService</tt> as a dependency and automatically
get triggered when a new result would have been fetched. Making multiple
HTTP API calls to fetch the same resource would be both a waste of time
and bandwidth.</p>
<p>You can also choose <em>not</em> to refresh certain controller scopes on
refresh. See <tt class="docutils literal">MyListLengthController</tt> here:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/30/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>A reason why you would want to do this would be if DOM generation is
slow and the resource being updated is a large one.</p>
<p>One issue with the above solution is that we can't handle the case when
a refresh fails. A way to remedy this is to use the <tt class="docutils literal">refresh()</tt> call's
<em>promise</em> instead of the actual resolved result. This moves the
responsibility of error handling from the service to each dependent
service/controller/component:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/31/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>Another issue with the above solution is we are partially back to the issue
we had with watch callback being called multiple times. In this example
it's because the <tt class="docutils literal">newList</tt> event is triggered twice on initialization.
This can be overcome by not triggering it on the first <tt class="docutils literal">refresh()</tt>
call:</p>
<iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/17/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>I know this became quite a lot of code. It all grew out of being a
simple example, but I think this journey is necessary to fully
understand what considerations goes into making reusable, refreshable,
services in Angular.</p>
<p>Last, but not least, don't just rip my example. Many times you are
totally fine with a service that simply fetches resource <em>once</em> per page
load!</p>
<p>Can I do this much simpler? Tell me in the comments.</p>
</div>


		<div id="article_meta">
							Category:
					<a href="http://jensrantil.github.io/category/misc.html">misc</a>
										<br />Tags:
									<a href="http://jensrantil.github.io/tag/angularjs.html">AngularJS</a>
									<a href="http://jensrantil.github.io/tag/javascript.html">JavaScript</a>
									</div>
	</article>

	<div class="donations">
		Dude, did you like this blog post? Feel free to
		drop me some bitcoins on
		<a href="bitcoin:1Q79HGDF3ZjfCwXLAW6e7gX4DeDu2GtZ7v">1Q79HGDF3ZjfCwXLAW6e7gX4DeDu2GtZ7v</a>.
	</div>

	<footer>
		<a href="http://jensrantil.github.io/" class="button_accent">&larr;&nbsp;&nbsp;&nbsp;Back to blog</a>
	</footer>

		<div id="comments">
		<h2>Comments</h2>
		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_identifier = "refreshable-angularjs-service.html";
			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = 'http://jensrantil.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view <a href="http://disqus.com/?ref_noscript">comments</a>.</noscript>
	</div>
	
	</section>

	<script type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script>
	<script type="text/javascript">
		try {
			var pageTracker = _gat._getTracker("UA-40929103-1");
			pageTracker._trackPageview();
		} catch(err) {}</script>
</body>
</html>