<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jens Rantil's Hideout</title><link href="http://jensrantil.github.io/" rel="alternate"></link><link href="http://jensrantil.github.io/feeds/all.atom.xml" rel="self"></link><id>http://jensrantil.github.io/</id><updated>2013-05-24T00:26:00+02:00</updated><entry><title>AngularJS events on initialization</title><link href="http://jensrantil.github.io/angularjs-events-on-initialization.html" rel="alternate"></link><updated>2013-05-24T00:26:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2013-05-24:angularjs-events-on-initialization.html</id><summary type="html">&lt;p&gt;In my &lt;a class="reference external" href="http://jensrantil.github.io/refreshable-angularjs-service.html"&gt;previous post&lt;/a&gt; I was giving an example of using &lt;a class="reference external" href="http://angularjs.org"&gt;AngularJS&lt;/a&gt;
&lt;a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$emit"&gt;events&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I stumbled across a corner case that might be worth noting; If a service
is triggering an event on initialization, no controllers will get
notified of it. Here's an example:&lt;/p&gt;
&lt;iframe width="100%" height="250"
src="http://jsfiddle.net/Ztyx/TdykU/2/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;The reason why this is happening is simply because the controller have
not been instantiated. Setting a timer before emitting the event can be
done as a workaround:&lt;/p&gt;
&lt;iframe width="100%" height="250"
src="http://jsfiddle.net/Ztyx/TdykU/3/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Now you know!&lt;/p&gt;
</summary><category term="AngularJS"></category><category term="JavaScript"></category></entry><entry><title>Refreshable AngularjS service</title><link href="http://jensrantil.github.io/refreshable-angularjs-service.html" rel="alternate"></link><updated>2013-05-23T22:59:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2013-05-23:refreshable-angularjs-service.html</id><summary type="html">&lt;p&gt;Lately I've been working a lot in &lt;a class="reference external" href="http://angularjs.org"&gt;AngularJS&lt;/a&gt;. This is my second project
with the framework, and the more time I spend in it, the more I like it.&lt;/p&gt;
&lt;p&gt;But as with most things, AngularJS has some rough corners. Its
&lt;a class="reference external" href="http://docs.angularjs.org/"&gt;documentation&lt;/a&gt; still has a long way to go, altough it has improved since
last time I used it over a year ago. Common use cases and &amp;quot;Angular-y&amp;quot;
was of doing things is another thing that I also feel is lacking out
there. I guess it could be considered documentation depending on how you
look at it.&lt;/p&gt;
&lt;p&gt;My intention with this blog post is to go through one such use case,
namely dealing with complex dependencies. The clientside application
that I've been working with lately has a bunch of quite complicated
dependencies and these JSFiddles turned out to be the perfect way for me
to flesh out how to deal with the dependencies in an structured fashion.
Specifically, this post will talk about:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;How to share state between controllers.&lt;/li&gt;
&lt;li&gt;How update/refresh state between controllers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The level of this tutorial is &lt;em&gt;intermediate&lt;/em&gt;. I expect you to know basic
AngularJS; state injection, controllers, about &lt;tt class="docutils literal"&gt;$timeout&lt;/tt&gt; and
services.&lt;/p&gt;
&lt;div class="section" id="a-slow-service"&gt;
&lt;h2&gt;A slow service&lt;/h2&gt;
&lt;p&gt;Let's say you have some data you would like to present to your user
and you prepare some data in your controller. In our case, a list:&lt;/p&gt;
&lt;iframe width="100%" height="150"
src="http://jsfiddle.net/Ztyx/U9A32/1/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;This is very basic AngularJS and I expect you to have no problems
understanding the mapping done here.&lt;/p&gt;
&lt;p&gt;But in the real world, we rarely hardcode things. We are usually
interested in dynamic data. There are two (major) alternatives to get
dynamic data into an AngularJS browser application - either generating
the data into your JS code, or you make an API call to your backend
after your AngularJS application has loaded. The latter is better if
your data takes some time to generate. If you have multiple
dependencies, fetching them asynchronously using multiple HTTP calls
usually also tend to decrease page loading times.&lt;/p&gt;
&lt;p&gt;Now, let's create a &lt;a class="reference external" href="http://docs.angularjs.org/guide/dev_guide.services"&gt;service&lt;/a&gt; that simulates a slower API call. It uses a
&lt;a class="reference external" href="http://docs.angularjs.org/api/ng.$q"&gt;promise&lt;/a&gt; to return an handler that deals with handling asynchronous
result. Here's the code:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/2/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Notice that it takes a couple of seconds before the result is presented
on the screen when you click &amp;quot;Result&amp;quot;.&lt;/p&gt;
&lt;p&gt;Also, it's worth making a mental note that we are storing &lt;em&gt;a promise&lt;/em&gt; to
the scope. This is not the same as the actual list. AngularJS
automatically resolves this as the actual returned list and presents it
in the generated HTML. One issue with saving a promises directly to the
scope is that you don't handle how to deal with errors if the promise
could not be resolved. Errors &lt;em&gt;do&lt;/em&gt; happen, and in most cases you are
better off explicitly dealing with then. Maybe you can simply ignore it?
Present an error message? Revert to the previous message? This why I
nowadays usually resolve all my promises like this:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/3/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Obviously, we are not generating any errors here, but you never know!
;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="refreshable-data-between-controllers"&gt;
&lt;h2&gt;Refreshable data between controllers&lt;/h2&gt;
&lt;p&gt;Let's say we would like share state between controllers. This can be
done by nesting controllers. Here's a basic example:&lt;/p&gt;
&lt;iframe width="100%" height="200"
src="http://jsfiddle.net/Ztyx/U9A32/4/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Now, let's say that we would like this state to to refresh ones in a
while. Let's simulate an element added:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/5/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;If you click &amp;quot;Result&amp;quot;, you'll notice that the two child controllers are
not being updated after 3 seconds. That's because their &lt;tt class="docutils literal"&gt;$scope&lt;/tt&gt;
members only are set when the child controllers are being created. What
we want is to &lt;a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$watch"&gt;watch&lt;/a&gt; changes made to the list:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/6/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;If you try the code above, you'll notice that it still doesn't work. The
reason is subtle; &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$scope.$watch&lt;/span&gt;&lt;/tt&gt; compares object by reference by
default. This means that it will check to see if &lt;tt class="docutils literal"&gt;$scope.mylist&lt;/tt&gt; is a
&lt;em&gt;different&lt;/em&gt; array than previously. It is not -- it's simply a modified
version of that same array. What we want is to compare for &lt;em&gt;object
equality&lt;/em&gt;. We do that by setting the third parameter to &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; when
calling &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$scope.$watch&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/8/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Finally, it works! But, as in the previous example, we want to avoid
sharing data between controllers through a parent controller. Instead,
we want to use a service:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/10/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;All good in the hood so far. Now, let's say we would like to support
refreshing data from our slow API endpoint. Maybe the user has a little
refresh button, or you'd like the controller to issue a refresh. This is
where things get a little messy.&lt;/p&gt;
&lt;p&gt;My first take on this:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/11/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;For simplicity, I've only included a single controller.&lt;/p&gt;
&lt;p&gt;Notice that my service now returns an object with the function
&lt;cite&gt;refresh()&lt;/cite&gt; bound to it. The &lt;cite&gt;refresh()&lt;/cite&gt; member function returns a
new promise every time it's called.&lt;/p&gt;
&lt;p&gt;Looking at the result we notice that the result is presented correctly.
However, what's interesting is that &lt;tt class="docutils literal"&gt;$scope.watchCallbackCalls&lt;/tt&gt;
eventually gets the value &lt;tt class="docutils literal"&gt;4&lt;/tt&gt;. This is because our promise returned
from &lt;tt class="docutils literal"&gt;refresh()&lt;/tt&gt; actually is modified twice; first when it's returned
by &lt;tt class="docutils literal"&gt;refresh()&lt;/tt&gt; and secondly when the promise is resolved. Since we
call &lt;tt class="docutils literal"&gt;refresh()&lt;/tt&gt; twice, our watcher gets called four times. The
expected number of watch callback calls are obviously 2 calls.&lt;/p&gt;
&lt;p&gt;How do we overcome this? Instead of using watchers on promises, we
&lt;a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$on"&gt;can&lt;/a&gt; &lt;a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$emit"&gt;use&lt;/a&gt; &lt;a class="reference external" href="http://docs.angularjs.org/api/ng.$rootScope.Scope#$broadcast"&gt;events&lt;/a&gt; when our promises are resolved:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/12/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Each event is triggered with newly fetched list as event argument.&lt;/p&gt;
&lt;p&gt;Since the service can't access the controller that uses it, we trigger
events from &lt;tt class="docutils literal"&gt;$rootScope&lt;/tt&gt;. For bigger applications you might
want to use the calling controller as a parameter to &lt;tt class="docutils literal"&gt;refresh()&lt;/tt&gt; avoid
bloating the &lt;tt class="docutils literal"&gt;$rootScope&lt;/tt&gt; with too many events (and possibly get
conflicting event names).&lt;/p&gt;
&lt;p&gt;Another nice property of using events is that also other services could
have &lt;tt class="docutils literal"&gt;MySimulatedSlowHTTPService&lt;/tt&gt; as a dependency and automatically
get triggered when a new result would have been fetched. Making multiple
HTTP API calls to fetch the same resource would be both a waste of time
and bandwidth.&lt;/p&gt;
&lt;p&gt;You can also choosing &lt;em&gt;not&lt;/em&gt; to refresh certain controller scopes on
refresh. See &lt;tt class="docutils literal"&gt;MyListLengthController&lt;/tt&gt; here:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/13/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;A reason why you would want to do this would be if DOM generation is
slow and the resource being updated is a large one.&lt;/p&gt;
&lt;p&gt;One issue with the above solution is that we can't handle the case when
a refresh fails. A way to remedy this is to use the &lt;tt class="docutils literal"&gt;refresh()&lt;/tt&gt; call's
&lt;em&gt;promise&lt;/em&gt; instead of the actual resolved result. This moves the
responsibility of error handling from the service to each dependent
service/controller/component:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/14/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;Another issue with the above solution is we are partially back to the issue
we had with watch callback being called multiple times. In this example
it's because the &lt;tt class="docutils literal"&gt;newList&lt;/tt&gt; event is triggered twice on initialization.
This can be overcome by not triggering it on the first &lt;tt class="docutils literal"&gt;refresh()&lt;/tt&gt;
call:&lt;/p&gt;
&lt;iframe width="100%" height="300"
src="http://jsfiddle.net/Ztyx/U9A32/17/embedded/"
allowfullscreen="allowfullscreen" frameborder="0"&gt;&lt;/iframe&gt;&lt;p&gt;I know this became quite a lot of code example. It all grew out of being
a simple example, but I think this journey is necessary to fully
understand what considerations goes into making reusable, refreshable,
services in Angular.&lt;/p&gt;
&lt;p&gt;Last, but not least, don't just rip my example. Many times you are
totally fine with a service that simply fetches resource &lt;em&gt;once&lt;/em&gt; per page
load!&lt;/p&gt;
&lt;p&gt;Can I do this much simpler? Tell med in the comments.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="AngularJS"></category><category term="JavaScript"></category></entry><entry><title>Migrating to Python 3</title><link href="http://jensrantil.github.io/migrating-to-python-3.html" rel="alternate"></link><updated>2013-05-19T21:25:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2013-05-19:migrating-to-python-3.html</id><summary type="html">&lt;p&gt;This post is partially related to my &lt;a class="reference external" href="http://jensrantil.github.io/cqrs-time-to-rewind.html"&gt;previous blog post&lt;/a&gt; about
&lt;a class="reference external" href="http://www.github.com/JensRantil/rewind"&gt;Rewind&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I initially started the implementation of Rewind in Python 2.7. I
constantly kept test coverage to 100%, and I tried to stick to &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Test-driven_development"&gt;TDD&lt;/a&gt; as
much as possible.  The Python testing tool &lt;a class="reference external" href="https://nose.readthedocs.org/en/latest/"&gt;Nose&lt;/a&gt; proved to be very
valuable, as did &lt;a class="reference external" href="https://travis-ci.org/JensRantil/rewind"&gt;Travis CI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After some time I thought &amp;quot;Hey, why work in Python 2 when Python 3 seems
around corner?&amp;quot;. I installed Python 3.2 on my laptop and started
executing those tests. Travis CI helped a lot here to always make sure
that Rewind was backward compatible with Python 2.7. Ever nervous about
a test failing? Make pull request on &lt;a class="reference external" href="http://www.github.com"&gt;Github&lt;/a&gt; and Travis CI will tell you
whether the pull request broke something or not. Highly convenient.
Migration to Python 3 can be summarized in three paragraphs:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Migrate from lists to iterators.&lt;/strong&gt; In many ways I like the changes to the
built-in functions &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;reduce&lt;/tt&gt;. Working with iterators are in
many ways a higher abstraction. I did have some code that expected these
functions to return lists. The flip side was that I sometimes had to
wrap in list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;someiter&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In hindsight, I probably should have used &lt;a class="reference external" href="http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions"&gt;list comprehensions&lt;/a&gt; for
many of those cases as they are more readable...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the 'bytes' type instead of 'string' where appropriate.&lt;/strong&gt;
&lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt; was introduced as a new type in Python 3. In the Rewind case,
this mostly involved ZeroMQ message frames handling, that takes
&lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt;. This also involved some conversion to and/or from &lt;tt class="docutils literal"&gt;bytes&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;string&lt;/tt&gt;. I tried to stick to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;UTF-8&lt;/span&gt;&lt;/tt&gt; for this.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use 'string.format(...)' instead of 'string % ...' pattern.&lt;/strong&gt; Nuff
said.&lt;/p&gt;
&lt;div class="section" id="looking-back"&gt;
&lt;h2&gt;Looking back&lt;/h2&gt;
&lt;p&gt;In general, Python 3 is very backwards compatible (but Python 2 is not
forward compatible). As far as I can recollect, the only conditionals I
needed to make Python3 were aliasing of imports:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# Python &amp;lt; 3&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ConfigParser&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;configparser&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ImportError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# Python &amp;gt;= 3&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;configparser&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</summary><category term="python"></category></entry><entry><title>Bootstrapping software projects</title><link href="http://jensrantil.github.io/bootstrapping-software-projects.html" rel="alternate"></link><updated>2013-05-19T21:22:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2013-05-19:bootstrapping-software-projects.html</id><summary type="html">&lt;p&gt;This post is partially related to my &lt;a class="reference external" href="http://jensrantil.github.io/cqrs-time-to-rewind.html"&gt;previous blog post&lt;/a&gt; about
&lt;a class="reference external" href="http://www.github.com/JensRantil/rewind"&gt;Rewind&lt;/a&gt; and &lt;a class="reference external" href="http://www.github.com/JensRantil/gorewind"&gt;GoRewind&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Even though I've been working as a full-time developer for the past 4-5
years, it still hits me how much boiler plate is required to create a
proper software project. In fact, I've seen so many times how extra
functionality is bundled into applications just because the alternative
would require many hours of setting things up. This despite the fact
that functionality is orthogonal and has totally different life cycles.&lt;/p&gt;
&lt;p&gt;Some of the things I'm thinking about are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Choosing a license and making sure that it is published correctly.
That is, included in all source files, including my snail mail address
etc. I even wrote a &lt;a class="reference external" href="https://github.com/JensRantil/rewind/blob/develop/rewind/server/test/test_code.py#L80"&gt;test for this&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For Python projects; setting up a proper &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt; file. This also
includes a bunch of reading figuring out why &lt;a class="reference external" href="https://pypi.python.org/pypi/distribute"&gt;Distribute&lt;/a&gt; should be
used instead of &lt;a class="reference external" href="https://pypi.python.org/pypi/setuptools"&gt;Setuptools&lt;/a&gt;. Not to mention understanding entry
points, test dependencies and publishing to &lt;a class="reference external" href="https://pypi.python.org/pypi"&gt;PyPi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For other projects; setting up a proper build system [3], figure out how
to run tests, bundle and distribute things etc.&lt;/li&gt;
&lt;li&gt;Choosing a testing platform. In my case &lt;a class="reference external" href="http://readthedocs.ord/docs/nose/"&gt;Nose&lt;/a&gt; proved to be a great
choice.&lt;/li&gt;
&lt;li&gt;Choosing a coding standard. I was tired of messing around in
undocumented code with mixed types of indentation. Both &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-0008/"&gt;PEP8&lt;/a&gt; and
&lt;a class="reference external" href="http://www.python.org/dev/peps/pep-0257/"&gt;PEP257&lt;/a&gt; proved invaluable. In fact, I took things to a new level and
created &lt;a class="reference external" href="https://github.com/JensRantil/rewind/blob/develop/rewind/server/test/test_code.py"&gt;coding standards tests&lt;/a&gt; that asserted all code adhered to
these two PEPs. It used the &lt;a class="reference external" href="https://github.com/jcrocholl/pep8"&gt;pep8&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/GreenSteam/pep257"&gt;pep257&lt;/a&gt; projects' APIs for this.  It
may sound too strict, but the fact is, it was wonderful to have these
automatically tested! Also, the fact that &lt;a class="reference external" href="http://golang.org"&gt;Go&lt;/a&gt; comes with &lt;a class="reference external" href="http://golang.org/cmd/go/#hdr-Run_gofmt_on_package_sources"&gt;its own
formatter&lt;/a&gt; has proven to me that it's a valuable direction to go.&lt;/li&gt;
&lt;li&gt;Choosing &lt;a class="reference external" href="http://semver.org/"&gt;versioning strategy&lt;/a&gt; and figuring out a &lt;a class="reference external" href="http://nvie.com/posts/a-successful-git-branching-model/"&gt;branching model&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="docutils footnote" frame="void" id="id1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[3]&lt;/td&gt;&lt;td&gt;Maven, make, grails, you name it.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Open Source projects also involves building a community; mailing lists,
contribution processes etc.&lt;/p&gt;
&lt;p&gt;It takes time to set things up. And it's surprising that we, the
Software Community haven't come further with some of these obstacles.&lt;/p&gt;
</summary><category term="software"></category><category term="bootstrapping"></category></entry><entry><title>CQRS - Time to Rewind</title><link href="http://jensrantil.github.io/cqrs-time-to-rewind.html" rel="alternate"></link><updated>2013-05-19T21:21:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2013-05-19:cqrs-time-to-rewind.html</id><summary type="html">&lt;p&gt;For the last year I've been thinking a lot about &lt;a class="reference external" href="http://www.cqrsinfo.com"&gt;CQRS&lt;/a&gt; [&lt;a class="reference external" href="http://martinfowler.com/bliki/CQRS.html"&gt;1&lt;/a&gt;], &lt;a class="reference external" href="http://martinfowler.com/eaaDev/EventSourcing.html"&gt;Event
Sourcing&lt;/a&gt; and distributed architecture using &lt;a class="reference external" href="http://www.zeromq.org"&gt;ZeroMQ&lt;/a&gt;. I first stumbled
across the concept of CQRS through the mailing list for a &lt;a class="reference external" href="http://www.meetup.com/SoftPub/"&gt;nerd meetup
in Helsingborg&lt;/a&gt;, Sweden. This led me to a lot of CQRS &lt;a class="reference external" href="http://msdn.microsoft.com/en-us/library/jj554200.aspx"&gt;reading&lt;/a&gt; and
&lt;a class="reference external" href="http://cqrs.wordpress.com/video/"&gt;videos&lt;/a&gt;, and with that the Event Sourcing data model.&lt;/p&gt;
&lt;p&gt;To try out CQRS and Event Sourcing in practise, I started writing an
open source event store about a year ago. I named it &lt;a class="reference external" href="http://www.github.com/JensRantil/rewind"&gt;Rewind&lt;/a&gt;. This also
opened up for me to try some concepts that I had never tried before [2].&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[2]&lt;/td&gt;&lt;td&gt;See below.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="section" id="cqrs-and-event-sourcing"&gt;
&lt;h2&gt;CQRS and Event Sourcing&lt;/h2&gt;
&lt;p&gt;But first, let's Rewind ;). Rewind's &lt;a class="reference external" href="https://github.com/JensRantil/rewind/blob/develop/README.rst"&gt;README&lt;/a&gt; does a fairly good job at an
elevator speech for &lt;em&gt;CQRS&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Have you ever been nervous of all those DBMSs schema changes when
you are deploying your applications? They are gonna take too long,
or break backward compatibility? Have you ever thought &amp;quot;Crap, I wish
I had stored that information since earlier&amp;quot;? Have you ever felt
your writing patterns and your reading patterns differ a lot, making
things harder to scale? Issues like these can be solved using &lt;em&gt;CQRS&lt;/em&gt;
and &lt;em&gt;event sourcing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CQRS&lt;/em&gt; (Command-Query Response Segregation) is an architectural pattern
that aims to solve these issues by splitting up your architectural
system into two parts:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A &lt;em&gt;write side&lt;/em&gt; that takes care of validating input and optimizes
for fast writes. The write side takes commands and outputs
corresponding events if the command validates correctly.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;read side&lt;/em&gt; that listens to incoming events from the write side.
The read side is optimized for fast reads and incrementally build
up state that can be queried fast.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While not required, it is common to use messaging between the
write and read sides. This means that the system will be in an
inconsistent state from time to time. This is usually not an issue
and came be overcome in various ways.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A couple of additional things to note about CQRS:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;As I see it, it is the architectural equivalent of &lt;cite&gt;the CQS design
pattern&lt;/cite&gt;.&lt;/li&gt;
&lt;li&gt;It is a pattern that decouples systems very well. This can have huge
implications when it comes to testability.&lt;/li&gt;
&lt;li&gt;It's also worth noting that there are some similarities between Domain
Driven Design (&lt;a class="reference external" href="http://www.wikipedia.org/Domain-driven_design"&gt;DDD&lt;/a&gt;) and CQRS. Most vocabularies in DDD are used in
CQRS; ubiquous language, aggregates, aggregrate root, value objects,
bounded contexts etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The README then states about &lt;em&gt;Event Sourcing&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A common pattern used together with CQRS is &lt;em&gt;event sourcing&lt;/em&gt;. The
concept can be summarized as using state changes as primary
persistence, instead of the final state. The state changes are
called &lt;em&gt;events&lt;/em&gt; and they are generated by the write side and
delivered to the read side.&lt;/p&gt;
&lt;p&gt;The events are persisted in an event store that sits inbetween the
read and write side of things. It takes care of three things:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;persisting all events to disk.&lt;/li&gt;
&lt;li&gt;being a hub/broker replicating all events from the write to the
read side of things.&lt;/li&gt;
&lt;li&gt;allowind fast querying of events so that different parts of the
system can be synced back on track and new components can be
brought back in play.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Rewind&lt;/h2&gt;
&lt;p&gt;Question was, how would a CQRS/event sourced system behave in
production?  Could it scale out? Could writes be partitioned? What about
fault tolerance? I was tired of heavy database schema changes, I wanted
a nouvaeu way of testing and question some of the common practices.&lt;/p&gt;
&lt;p&gt;Enter &lt;a class="reference external" href="http://www.github.com/JensRantil/rewind"&gt;Rewind&lt;/a&gt;; Rewind was my pet project for a &lt;a class="reference external" href="https://github.com/JensRantil/rewind/graphs/commit-activity"&gt;major part of 2012&lt;/a&gt;. It
was &lt;em&gt;a Python implementation of an event store that supported multiple
backends&lt;/em&gt;. It really gave me an opportunity to try everything I wanted.&lt;/p&gt;
&lt;p&gt;The development of Rewind halted at the beginning of 2013. From thereon,
I instead used the lessons I had learnt and rewrote Rewind's
functionality in &lt;a class="reference external" href="http://www.golang.org"&gt;Go&lt;/a&gt;. The project was named &lt;a class="reference external" href="https://www.github.com/JensRantil/gorewind"&gt;GoRewind&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Within the next couple of blog posts I plan to write about what I've
learnt from these two projects; design decisions, testability, ZeroMQ,
developing in Go among other things.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="cqrs"></category><category term="distributed-architecture"></category></entry><entry><title>That initial blogpost</title><link href="http://jensrantil.github.io/that-initial-blogpost.html" rel="alternate"></link><updated>2013-05-14T22:40:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2013-05-14:that-initial-blogpost.html</id><summary type="html">&lt;p&gt;So it's time to kick off this blog. I cheated a little and posted
&lt;a class="reference external" href="http://jensrantil.github.io/replacing-a-folder-in-subversion.html"&gt;a previously written blog post&lt;/a&gt;.
It was posted on a personal blog that mostly had Swedish material.&lt;/p&gt;
&lt;p&gt;My intent with this blog will be to &amp;quot;put a URL on my tech and
possibly entrepreneurship thoughts, in English&amp;quot;. If you'd like to know
more about me, check out that brand new &lt;a class="reference external" href="http://jensrantil.github.io/pages/about-jens.html"&gt;About Me&lt;/a&gt; page!&lt;/p&gt;
</summary></entry><entry><title>Replacing a folder in Subversion</title><link href="http://jensrantil.github.io/replacing-a-folder-in-subversion.html" rel="alternate"></link><updated>2008-09-22T02:17:00+02:00</updated><author><name>Jens Rantil</name></author><id>tag:jensrantil.github.io,2008-09-22:replacing-a-folder-in-subversion.html</id><summary type="html">&lt;p&gt;So you have an external library foo version 1.0 that you have committed
to your Subversion repository together with your code. Let us for
simplicity say that your external library is situated in its own folder.&lt;/p&gt;
&lt;p&gt;One day you realize that there is a new version 2.0 of foo released. You
download it and since there was a while ago a lot of the file structure
in the foo project has changed. How can you replace the files in your
current repository in a good looking fashion?&lt;/p&gt;
&lt;p&gt;Now you could remove the old foo-library. Commit, and import the new
version of foo. But for me I always think it's important that a commit
is correctly reflecting a change. And I would say that upgrading the foo
library should be done in ONE commit. How do you do this? It turns out
it's a pretty hard problem and something that does not exist in todays
Subversion.&lt;/p&gt;
&lt;p&gt;I solved this by running &lt;tt class="docutils literal"&gt;rsync&lt;/tt&gt; from the new library folder to the old
library folder, ignoring the &lt;tt class="docutils literal"&gt;.svn&lt;/tt&gt;-folders:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;rsync -vlr --exclude&lt;span class="o"&gt;=&lt;/span&gt;.svn --delete foo_new/ foo_old/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Executing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;svn status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then gave a me a list of all newly added files (question marks), removed
files (conflicts/exclamation marks) and changed files (M, as in
modified). The added files and removed files then manually had to be
added/removed in my local checkout before committing - something that
could have been scripted if I wasn't doing this at 2:30 in the morning
:-)&lt;/p&gt;
&lt;p&gt;Please comment if you do have a better solution.&lt;/p&gt;
</summary><category term="svn"></category><category term="subversion"></category></entry></feed>