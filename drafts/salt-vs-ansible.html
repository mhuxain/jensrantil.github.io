<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="http://jensrantil.github.io/theme/css/style.css">
	<!--<link rel="stylesheet/less" type="text/css" href="/theme/css/style.less">-->
	<!--<script src="/theme/js/less.js" type="text/javascript"></script>-->
	<link rel="stylesheet" type="text/css" href="http://jensrantil.github.io/theme/css/pygments.css">
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>

	<link href="http://jensrantil.github.io/" type="application/atom+xml" rel="alternate" title="Jens Rantil's Hideout ATOM Feed" />
	
	
			<title>Jens Rantil's Hideout</title>
		<meta charset="utf-8" />
	</head>
<body>
	<section id="sidebar">
		<figure id="user_logo">
            <a href="http://jensrantil.github.io"><div class="logo">&nbsp;</div></a>
		</figure>

		<div class="user_meta">
            <h1 id="user"><a href="http://jensrantil.github.io" class="">Jens Rantil</a></h1>
			<h2></h2>
						<p class="bio">Swedish/English, fullstack software engineer (<a href="http://www.tinkapp.com" target="_blank">@Tink</a>), <a href="http://www.lth.se/english/education/programmes/master_engineering/engineering_mathematics/">MSc in Engineering Mathematics</a>, traveller, nerd, juggler, guitarist, african drum player. Inspired Swede.</p>
						<ul>
																			<li><a href="http://jensrantil.github.io/pages/about-jens.html">About Jens</a></li>
																		<li><a href="http://www.twitter.com/JensRantil">Twitter</a></li>
									<li><a href="http://www.github.com/JensRantil">Github</a></li>
									<li><a href="http://www.linkedin.com/in/jensrantil">LinkedIn</a></li>
							</ul>
		</div>
		<footer>
			<address>
				Powered by <a href="http://pelican.notmyidea.org/">Pelican</a>,
		                theme by <a href="https://github.com/wting/pelican-svbtle">wting</a>.
			</address>
		</footer>
	</section>

	<section id="posts">
			<header>
		<h1>Jens Rantil's blog</h1>
		<h3>Posted Mon 17 March 2014</h3>
	</header>
	<article>
		<h1 id="title">
			<a href="http://jensrantil.github.io/salt-vs-ansible.html" rel="bookmark"
				title="Permalink to Salt vs. Ansible">Salt vs. Ansible</a>
		</h1>
		<p>Recently I was set to evaluate configuration management systems. I've
heard opinions from someone I respect that <a class="reference external" href="http://puppetlabs.com">Puppet</a> and <a class="reference external" href="http://www.getchef.com">Chef</a> were
complicated beasts to get up and running, and since I am a Python guy
I've generally always kept an eye on <a class="reference external" href="http://www.ansible.com">Ansible</a> and <a class="reference external" href="http://www.saltstack.com">Salt</a>. Ruby is so far
not my thing, but hey let's not start a flamewar about that!</p>
<p>Last year I got to spend a good 6 months working with Ansible for
provisioning of servers. I became very familiar with the tool. In that
project, Ansible was mostly chosen because it was easy to get started
and had good documentation. The team I was working with was especially
fond of the <a class="reference external" href="http://docs.ansible.com/playbooks_best_practices.html">Best Practises</a> documentation which got us started quickly
and taught us what structure had worked previously.</p>
<p>Three weeks ago I went on a 10-day vacation in Japan, and for those who
don't know me that usually equals me spending a fair amount of time of
reading computer literature or documentation! Inbetween great sushi,
Tokyo skylines, amazing skiing and rough flue I found <a class="reference external" href="https://media.readthedocs.org/pdf/salt/latest/salt.pdf">the Salt
PDF-documentation</a> to be great leisure!</p>
<p>I've also spent some time getting a Salt setup up and running with their
<a class="reference external" href="http://docs.saltstack.com/topics/tutorials/starting_states.html">States</a> system. Since I now feel like I have a pretty robust background
in both systems, I feel obliged to make a highly opinionated comparison.
Let's go:</p>
<div class="section" id="terminology">
<h2>Terminology</h2>
<p>Both Salt and Ansible are originally built as execution engines. That
is, they allow executing commands on one or more remote systems, in
parallel if you want.</p>
<p>Ansible supports executing arbitrary command line commands on multiple
machines. It also supports executing <em>modules</em>. An <a class="reference external" href="http://docs.ansible.com/modules.html">Ansible module</a> is
basically a Python module written in a certain Ansible friendly way.
Most standard Ansible modules are idempotent. This means you tell them
the state you'd want your system to be in, and the module tries to make
the system look like that.</p>
<p>Ansible also has the concept of a <a class="reference external" href="http://docs.ansible.com/playbooks.html">Playbook</a>. A playbook is a file that
defines a series of module executions for a set of hosts. A playbook can
vary the hosts modules are executed on. This makes it possible to
orchestrate multiple machines, such as take them out of a load balancers
before upgrading an application.</p>
<p>Salt has two types of modules; <a class="reference external" href="http://docs.saltstack.com/ref/modules/all/index.html">execution modules</a> and <a class="reference external" href="http://docs.saltstack.com/ref/states/all/index.html">state modules</a>.
Execution modules are modules simply executes something, it could be a
command line execution, or downloading a file. A state module is more
like an Ansible module, where the arguments define a state and the
module tries to fulfill that end state. In general state modules are
using execution modules to most of their work.</p>
<p>State modules are executed using the the <tt class="docutils literal">state</tt> execution module. The
state module also supports defining states in files, called SLS files.
Which states to apply to which hosts is defined in a <a class="reference external" href="http://docs.saltstack.com/ref/states/top.html">top.sls</a> file.</p>
<p>Both playbooks and SLS files (usually) are written in YAML.</p>
<p>As a side-note I want to point out the a remote execution engine is
highly useful for tasks such as doing inventory or kick off a certain
operation on multiple machines.</p>
<div class="section" id="architecture">
<h3>Architecture</h3>
<p>Salt is built around a <em>Salt master</em> and multiple <em>Salt minions</em> that
are connecting to the master when they boot. Generally, commands are
issued on the master command line. The master then dispatches those
commands out to minions. Initially minions initiate a handshake
consisting of a cryptographic key exchange and after that they have a
persistent encrypted TCP connection. I could babble at length about how
they are using the <a class="reference external" href="http://zeromq.org">ZeroMQ</a> library for communication, but let's just say
that a Salt master can handle a _lot_ of minions without being
overloaded thanks to ZeroMQ.</p>
<p>Because minions have a persistent connection to Salt master commands are
fast to reach the minions. The minions also cache various data to make
execution faster.</p>
<p>Ansible is masterless and it uses SSH as it's primary communication
layer.  This means it is slower, but being masterless might make it
slightly easier to run setup and test Ansible playbooks. Some claim it's
also more secure because it doesn't require another server application.
Read more about that under &quot;Security&quot; further down.</p>
<p>Ansible does support a ZeroMQ version, but it requires an initial SSH
connection to setup. I tried it, and to be honest I didn't see that much
of a speedup. I guess bigger improvements can be seen for larger
playbooks and more hosts.</p>
<p>To keep track of machines Ansible recommends you have an <em>inventory</em>
file that basically contains a list of hosts, grouped by groups,
possibly with attributes added to either a group or a single host. You
can have multiple inventory files, say, one for staging and one for
production.</p>
<p>Salt also supports using SSH instead of ZeroMQ using <a class="reference external" href="http://docs.saltstack.com/topics/ssh/">Salt SSH</a>. But
beware, it's alpha software (and I haven't tried it)...</p>
</div>
<div class="section" id="community">
<h3>Community</h3>
<p>For both projects I've had inquiries both on IRC and on mailing list.
I've also contributed patches to them both - Python code and
documentation patches. Here's a summary of my experience:</p>
<p>Ansible: Quick friendly response on IRC. The rest of the project
seems to be less of a community effort and more a one-man-show lead by
Michael DeHaan. I'm sorry to say, but I enjoy communities that are
more open to improvements and has a friendlier tone. Ansible
improvement issues are closed before fixed, which I feel like is hiding
issues under the rug. Good news all inquiries has been getting a
response.</p>
<p>Salt has so far proven to be a more welcoming community. IRC
responses has mostly been quick and friendly. Sometimes I've had to
resort to the mailing list. I've had a couple of mailing list issues
that has taken ~4 days to get a response on, but it seems like most
threads will get a follow-up response eventually.</p>
<p>My clear impression is that Salt has a more mature community in terms of
tone, welcomeness and collaboration. I'm probably stepping on a lot of
people's toes saying this, but hey - this is an oppinionated review!</p>
</div>
</div>
<div class="section" id="speed">
<h2>Speed</h2>
<p>While you might think that speed is not important when you have a few
servers, I believe you are wrong. Being able to iterate fast is always
important. Period. A slow startup slows you down. If something takes
more than 30 seconds to compile I end up on Twitter, which means
compiling just took 120 seconds. It's the same with deployment.</p>
<p>Ansible is always using SSH for initiating connections. This is slow.
Its ZeroMQ implementation (mentioned earlier) does help, but
initialization is still slow.  Salt uses ZeroMQ by default, and it is
_fast_.</p>
<p>Like said earlier, Salt has a permanent minion processes. This enables
Salt to cache files for faster reexecution of things.</p>
</div>
<div class="section" id="code-structure">
<h2>Code structure</h2>
<p>My biggest pet peeve with Ansible modules is that they can't be imported
(because they are <a class="reference external" href="https://github.com/JensRantil/ansible/blob/devel/library/files/copy#L189">executing code on import</a>). This means there's some
magic involved when testing modules because you can't import a module
like any other. I don't like magic. I prefer pure simple code. This is
more of the Salt style.</p>
<p>Using less magic also means that it is more clear how to write test
suites for Salt modules. Salt is thouroughly tested. It also made me
happy to see that Salt comes with a <a class="reference external" href="http://docs.saltstack.com/topics/development/tests/">three</a> <a class="reference external" href="http://docs.saltstack.com/topics/tests/integration.html">chapters</a> on <a class="reference external" href="http://docs.saltstack.com/topics/development/tests/unit.html">testing</a>,
including the fact that they encourage mocking to enable testing of
infrastructure if you don't have, say, a MySQL instance.</p>
<p>The above said, Ansible has a pretty clean code in general. I managed to
navigate it pretty quickly. However, <a class="reference external" href="https://groups.google.com/d/msg/ansible-project/mpRFULSiIQw/jIIQdOSubnUJ">improving code structure</a> was
clearly not of interest to the &quot;community&quot;.</p>
<p>Both Ansible and Salt have regular installables <a class="reference external" href="https://pypi.python.org/pypi/ansible">via</a> <a class="reference external" href="https://pypi.python.org/pypi/salt">PyPi</a>.</p>
</div>
<div class="section" id="vagrant">
<h2>Vagrant</h2>
<p>While talking about testing... DevOps people loves Vagrant. Until
recently I had not worked with it.  Vagrant comes with provisioning
modules both for Salt and Ansible. This makes it a breeze to get up and
running with a master+minion in Vagrant, or executing a playbook on
startup.</p>
</div>
<div class="section" id="orchestration">
<h2>Orchestration</h2>
<p>Both Ansible and Salt supports orchestration. I'd say orchestration
rules generally are easier to get an overview of in Ansible. Basically,
a playbook is split up in groups of tasks, where each group matches to a
set of hosts (or a hostgroup). Each group is executed chronologically
according to order. The same comes for the executions order of tasks.</p>
<p>Salt supports <a class="reference external" href="http://docs.saltstack.com/topics/event/index.html">events</a> and <a class="reference external" href="http://docs.saltstack.com/topics/reactor/">reactors</a> to those events. This means a Salt
execution can trigger things on another machine. Salt's execution engine
also enables things such as monitoring and it's going to be really
interesting to see what comes of that in the future. For basic
orchestration you can also use <a class="reference external" href="http://docs.saltstack.com/ref/states/overstate.html">Overstate</a> to set up various roles in a
cluster in a special order.</p>
<p>Ansible wins here because of its simplicity. Salt wins in features
because of it being able to react continuously to cluster changes.</p>
<p>Both Salt and Ansible also supports executing tasks over a window of
machines. This is useful to make sure a service is always available
through for example an upgrade.</p>
</div>
<div class="section" id="security">
<h2>Security</h2>
<p>Ansible uses SSH for transport. SSH is a battle tested protocol. As long
as the SSH server is correctly configured (with a good random number
generator), I believe most people would assume an SSH client is secure.</p>
<p>Ansible can also easily connect as multiple non-root users to a single
host. If you are extremelly picky about having processes running as
<tt class="docutils literal">root</tt> you should evaluate Ansible. That said, Ansible supports using
<tt class="docutils literal">sudo</tt> to execute it's modules as <tt class="docutils literal">root</tt>. If you don't want to
connect over SSH as <tt class="docutils literal">root</tt>, that is.</p>
<p>Salt uses it's &quot;own&quot; AES implementation and key handling. By &quot;own&quot; I
want to make a point out that it uses the <a class="reference external" href="https://www.dlitz.net/software/pycrypto/">PyCrypto</a> package for this.
There <a class="reference external" href="http://www.cvedetails.com/vulnerability-list/vendor_id-12943/product_id-26420/version_id-155046/Saltstack-Salt-0.17.0.html">has</a> been security issues with Salt, but at the same time I think
the architecture is so simple that security is fairly easy to maintain.</p>
<p>What's also important to note is that Salt runs it's master and minions
as <tt class="docutils literal">root</tt> by default. This can be changed, but obviously it can be
hard to install Debian packages etc. if you are not root. As for the
master, you can configure it to allow the <tt class="docutils literal">salt</tt> command as non-root.
I highly recommend that.</p>
<div class="section" id="sensitive-data">
<h3>Sensitive data</h3>
<p>All sensitive data being
rolled out will at some point need to reside on the provisioning
machine. If the provisioning machine is a sysadmin's machine, which
nowadays usually are laptops, you risk having that data stolen.</p>
<p>After deep and long thinking about this I believe the authoritarian
master approach is a better one. This means sensitive data can be
enforced to only reside on one locked down place (with encrypted
backups, of course). Salt lets you store security credentials in
&quot;Pillars&quot;.  Sure, a master intrusion would be devastating, but you only
need to secure one machine. Not all developer machines in cafés, on
trains and airports.</p>
<p>Obviously, Ansible users do have the option to always execute their
playbooks from a secured machine that holds the sensitive data. But is
this was people do?</p>
</div>
<div class="section" id="auditability">
<h3>Auditability</h3>
<p>When talking about security I also think auditability is important.
Here, Salt wins big. Every execution Salt does is <a class="reference external" href="http://docs.saltstack.com/topics/jobs/index.html">stored</a> for X number of
days on the master. This makes it easy to both debug, but also see if
there's been anything fishy going on.</p>
</div>
</div>
<div class="section" id="deployment">
<h2>Deployment</h2>
<p>Ansible is definitely easier here. No deployment is needed. Sure, Salt
supports SSH but the documentation mostly assumes ZeroMQ. But hey, SSH
is slow anyway...</p>
<p>A nice thing about provisioning minions is that they are the ones
connecting to the master. This makes it quick and easy to bootstrap a
bunch of new machines quickly. The minion-connects architecture is also
useful if you'd like to use something like Amazon's autoscaling
features. Each autoscaled instance will automatically become a minion.</p>
<p>The Salt <a class="reference external" href="https://github.com/saltstack/salt-bootstrap">bootstrap script</a> is incredibly useful for bootstrapping and
makes it a breeze. It handles a bunch of different distributions and is
<a class="reference external" href="http://salt.readthedocs.org/en/latest/topics/tutorials/salt_bootstrap.html">well documented</a>.</p>
</div>
<div class="section" id="learning-curve">
<h2>Learning curve</h2>
<p>Ansible wins here. It's easier to get started and comprehend. Mostly
because nothing else is needed than cloning the Ansible GIT repo,
setting a couple of environment variables and starting to execute your
playbooks.</p>
<p>Salt can run in <a class="reference external" href="http://docs.saltstack.com/topics/tutorials/quickstart.html">masterless mode</a>. This makes it easier to get it up
and running. However, for production (and stability) I recommend getting
an actual master up and running.</p>
<p>Generally, Salt comes with more bells and whistles but the cost is that
the learning curve is steeper. Salt is <a class="reference external" href="http://docs.saltstack.com/topics/development/modular_systems.html">highly modular</a>. This is great
in terms of code structure but requires more parts to be understood to
fully grok Salt.</p>
</div>
<div class="section" id="upgrading">
<h2>Upgrading</h2>
<p>Upgrading Salt depends on how it was installed. For Debian based
distributions there is an <tt class="docutils literal">apt</tt> repository holding the latest Debian
packages. So upgrading is simply <tt class="docutils literal"><span class="pre">apt-get</span> upgrade</tt>. For Ubuntu, there
is a PPA. Both repositories are actively maintained. The latest
<tt class="docutils literal">2014.1.0</tt> release that came out recently had its Debian/Ubuntu
packages packaged within a week (and that was long!).</p>
<p>Upgrading Ansible is even simpler; You simply execute <tt class="docutils literal">git fetch
&amp;&amp; git checkout &lt;tag&gt;</tt>. That's it.</p>
</div>
<div class="section" id="documentation">
<h2>Documentation</h2>
<p>As of documentation, both projects have all information you need to get
up and running, developing modules and configure setups. Ansible has
historically had a better structure of its documentation than Salt.
That said, there has been <a class="reference external" href="https://github.com/saltstack/salt/issues/10526">great</a> <a class="reference external" href="https://github.com/saltstack/salt/pull/10792">effort</a> to structure the Salt
documentation recently. I contributed a lot of issues to that goal and
most of them have been fixed.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>To me, Ansible was a great introduction to automated server
configuration and deployment. It was easy to get up and running and has
great documentation.</p>
<p>Moving forward, the scalability, speed and architecture of Salt suits my new
project better. For cloud deployments I find the Salt architecture to be
a better fit. I'm happy with my choice.</p>
<p>All this said, you should give both projects a spin before making your
decision. They're fairly quick to set up and test.</p>
</div>


		<div id="article_meta">
							Category:
					<a href="http://jensrantil.github.io/category/misc.html">misc</a>
										<br />Tags:
									<a href="http://jensrantil.github.io/tag/salt.html">Salt</a>
									<a href="http://jensrantil.github.io/tag/ansible.html">Ansible</a>
									<a href="http://jensrantil.github.io/tag/provisioning.html">provisioning</a>
									</div>
	</article>

	<div class="donations">
		Dude, did you like this blog post? Feel free to
		drop me some bitcoins on
		<a href="bitcoin:1Q79HGDF3ZjfCwXLAW6e7gX4DeDu2GtZ7v">1Q79HGDF3ZjfCwXLAW6e7gX4DeDu2GtZ7v</a>.
	</div>

	<footer>
		<a href="http://jensrantil.github.io/" class="button_accent">&larr;&nbsp;&nbsp;&nbsp;Back to blog</a>
	</footer>

		<div id="comments">
		<h2>Comments</h2>
		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_identifier = "salt-vs-ansible.html";
			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = 'http://jensrantil.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view <a href="http://disqus.com/?ref_noscript">comments</a>.</noscript>
	</div>
	
	</section>

	<script type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script>
	<script type="text/javascript">
		try {
			var pageTracker = _gat._getTracker("UA-40929103-1");
			pageTracker._trackPageview();
		} catch(err) {}</script>
</body>
</html>